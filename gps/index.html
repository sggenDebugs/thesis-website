<!DOCTYPE html>
<html>
<head>
  <title>Bike Tracking System</title>
  <style>
    #map {
      height: 600px;
      width: 100%;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 5px;
      font-family: Arial, sans-serif;
    }
    #status p {
      margin: 5px 0;
      font-size: 16px;
    }
    .locked {
      color: #dc3545; /* Red for locked */
    }
    .unlocked {
      color: #28a745; /* Green for unlocked */
    }
  </style>
</head>
<body>
  <h1>Live Bike Tracking</h1>
  <div id="map"></div>
  <div id="status">
    <p id="bike-id">Bike ID: Unknown</p>
    <p id="lock-status">Bike: Unknown</p>
    <p id="rented-time">Rented: Not rented</p>
    <p id="returned-time">Returned: Not returned</p>
  </div>

  <!-- Include Socket.IO client -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script>
    let marker;
    let map;
    const bikeId = 373; // Your bike ID
    let trailPath;
    let trailCoordinates = [];
    let currentPosition = null;
    let targetPosition = null;
    let animationStartTime = null;
    const animationDuration = 1200;

    function initMap() {
      const bikeIcon = {
        url: '/img/bike-icon.png',
        scaledSize: new google.maps.Size(50, 50),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(25, 25)
      };

      // Initialize Google Map
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 9.30687095402185, lng: 123.30439309577068 },
        zoom: 18.5,
        streetViewControl: false
      });

      // Create bike marker
      marker = new google.maps.Marker({
        position: map.getCenter(),
        map: map,
        icon: bikeIcon,
        optimized: false
      });

      // Create the trail polyline
      trailPath = new google.maps.Polyline({
        path: trailCoordinates,
        geodesic: true,
        strokeColor: '#FF0000',
        strokeOpacity: 1.0,
        strokeWeight: 2
      });
      trailPath.setMap(map);

      // Initialize Socket.IO connection
      const socket = io('wss://cedolis.online:3000', {
        transports: ['websocket'],
        auth: {
          bikeId: bikeId
        }
      });

      // Register bike and request bike info on connection
      socket.on('connect', () => {
        console.log('Connected to WebSocket server');
        socket.emit('register-bike', bikeId);
        socket.emit('get-bike-info', bikeId);
      });

      // Listen for position updates
      socket.on('position', (data) => {
        handleNewPosition(data.lat, data.lng, data.timestamp);
      });

      // Listen for bike info updates
      socket.on('bike-info', (data) => {
        console.log('Received bike info:', data);
        const bikeIdElement = document.getElementById('bike-id');
        const lockStatus = document.getElementById('lock-status');
        const rentedTime = document.getElementById('rented-time');
        const returnedTime = document.getElementById('returned-time');

        bikeIdElement.textContent = `Bike ID: ${data.bike_id}`;
        lockStatus.textContent = `Bike: ${data.state.charAt(0).toUpperCase() + data.state.slice(1)}`;
        lockStatus.className = data.state === 'locked' ? 'locked' : 'unlocked';
        rentedTime.textContent = data.rented_at ? `Rented: ${new Date(data.rented_at).toLocaleString()}` : 'Rented: Not rented';
        returnedTime.textContent = data.returned_at ? `Returned: ${new Date(data.returned_at).toLocaleString()}` : 'Returned: Not returned';
      });

      // Handle errors from bike info request
      socket.on('bike-info-error', (error) => {
        console.error('Bike info error:', error.message);
        const lockStatus = document.getElementById('lock-status');
        lockStatus.textContent = `Bike: Error - ${error.message}`;
        lockStatus.className = 'locked'; // Default to red for errors
      });

      // Log connection errors
      socket.on('connect_error', (err) => {
        console.error('Connection error:', err.message);
      });
    }

    function handleNewPosition(lat, lng, timestamp) {
      const newPosition = new google.maps.LatLng(lat, lng);

      // Set initial position or animate transition
      if (!currentPosition) {
        currentPosition = newPosition;
        marker.setPosition(currentPosition);
      } else {
        targetPosition = newPosition;
        animationStartTime = null;
        requestAnimationFrame(animate);
      }

      // Update the trail
      trailCoordinates.push(newPosition);
      trailPath.setPath(trailCoordinates);
    }

    // Linear interpolation between two positions
    function lerp(start, end, progress) {
      return new google.maps.LatLng(
        start.lat() + (end.lat() - start.lat()) * progress,
        start.lng() + (end.lng() - start.lng()) * progress
      );
    }

    // Animate the marker
    function animate(timestamp) {
      if (!currentPosition || !targetPosition) {
        console.warn("Animation skipped: Missing position data");
        return;
      }

      if (!animationStartTime) animationStartTime = timestamp;
      const elapsed = timestamp - animationStartTime;
      const progress = Math.min(elapsed / animationDuration, 1);

      try {
        const intermediatePos = lerp(currentPosition, targetPosition, progress);
        marker.setPosition(intermediatePos);

        // Compute heading for marker rotation
        const heading = google.maps.geometry.spherical.computeHeading(
          currentPosition,
          targetPosition
        );

        const bikeIcon = {
          url: '/img/bike-icon.png',
          scaledSize: new google.maps.Size(50, 50),
          origin: new google.maps.Point(0, 0),
          anchor: new google.maps.Point(25, 25)
        };
        marker.setIcon({ ...bikeIcon, rotation: heading });

        // Smooth map panning
        const currentCenter = map.getCenter();
        const newCenter = new google.maps.LatLng(
          currentCenter.lat() + (intermediatePos.lat() - currentCenter.lat()) * 0.1,
          currentCenter.lng() + (intermediatePos.lng() - currentCenter.lng()) * 0.1
        );
        map.panTo(newCenter);
      } catch (error) {
        console.error("Animation error:", error);
        animationStartTime = null;
        return;
      }

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        currentPosition = targetPosition;
        animationStartTime = null;
      }
    }
  </script>

  <!-- Load Google Maps API -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCewoqc0dlIGMOb0uHPZE2B_IP05bs2MCc&libraries=geometry&callback=initMap">
  </script>
</body>
</html>